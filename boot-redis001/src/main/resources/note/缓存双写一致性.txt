1.Redis与MySQL数据双写一致性工程落地案例
  canal是什么?
    canal [kə'næl]，中文翻译为 水道/管道/沟渠/运河，主要用途是用于 MySQL 数据库增量日志数据的订阅、消费和解析，是阿里巴巴开发并开源的，采用Java语言开发；

    历史背景是早期阿里巴巴因为杭州和美国双机房部署，存在跨机房数据同步的业务需求，实现方式主要是基于业务 trigger（触发器） 获取增量变更。
    从2010年开始，阿里巴巴逐步尝试采用解析数据库日志获取增量变更进行同步，由此衍生出了canal项目；

  canal能干嘛?
   数据库镜像
   数据库实时备份
   索引构建和实时维护(拆分异构索引、倒排索引等)
   业务 cache 刷新
   带业务逻辑的增量数据处理

  canal去哪下?
   下载canal: https://github.com/alibaba/canal/wiki/QuickStart
   java案例 : https://github.com/alibaba/canal/wiki/ClientExample

  canal工作原理?
    1.传统MySQL主从复制工作原理
      MySQL的主从复制将经过如下步骤：
       1、当 master 主服务器上的数据发生改变时，则将其改变写入二进制事件日志文件中；
       2、salve 从服务器会在一定时间间隔内对 master 主服务器上的二进制日志进行探测，探测其是否发生过改变，
       如果探测到 master 主服务器的二进制事件日志发生了改变，则开始一个 I/O Thread 请求 master 二进制事件日志；
       3、同时 master 主服务器为每个 I/O Thread 启动一个dump  Thread，用于向其发送二进制事件日志；
       4、slave 从服务器将接收到的二进制事件日志保存至自己本地的中继日志文件中；
       5、salve 从服务器将启动 SQL Thread 从中继日志中读取二进制日志，在本地重放，使得其数据和主服务器保持一致；
       6、最后 I/O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒；
    2.canal工作原理
      canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议
      MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )
      canal 解析 binary log 对象(原始为 byte 流)

    结论: 分布式系统只有最终一致性，很难做到强一致性

    mysql-canal-redis双写一致性Coding: RedisCanalClientOperator.java

2.缓存双写一致性
  如果redis中有数据, 需要和数据库中的值相同
  如果redis中无数据, 数据库中的值要是最新值

3.缓存按照操作来分，有细分2种
  1.只读缓存
  2.读写缓存
     同步直写策略：写缓存时也同步写数据库，缓存和数据库中的数据⼀致；
     对于读写缓存来说，要想保证缓存和数据库中的数据⼀致，就要采⽤同步直写策略

4.数据库和缓存一致性的几种更新策略
  目标?
   给缓存设置过期时间，是保证最终一致性的解决方案。

   可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，
   那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，切记以mysql的数据库写入库为准。

   上述方案和后续落地案例是调研后的主流+成熟的做法，但是考虑到各个公司业务系统的差距，
   不是100%绝对正确，不保证绝对适配全部情况，请同学们自行酌情选择打法，合适自己的最好。

   总之，要达到最终一致性！

  讨论3种更新策略?
    1. 先更新数据库，再更新缓存，不使用
       异常问题?
         1 先更新mysql的某商品的库存，当前商品的库存是100，更新为99个。
         2 先更新mysql修改为99成功，然后更新redis。
         3 此时假设异常出现，更新redis失败了，这导致mysql里面的库存是99而redis里面的还是100 。
         4  上述发生，会让数据库里面和缓存redis里面数据不一致，读到脏数据。

    2.先删除缓存，再更新数据库  热点key会出现缓存击穿
      异常问题？
       1 A线程先成功删除了redis里面的数据，然后去更新mysql，此时mysql正在更新中，还没有结束。（比如网络延时）B突然出现要来读取缓存数据。
         代码详见：CacheConsistence.deleteUser()

       2 此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，此处出来2个问题：
         2.1 B从mysql获得了旧值
              B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。
         2.2 B会把获得的旧值写回redis
            获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能又被写回了)。
         代码详见: CacheConsistence.selectUser()

       3. A线程更新完mysql，发现redis里面的缓存是脏数据
           两个并发操作，一个是更新操作，另一个是查询操作，A更新操作删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，
           然后A更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。

       4 总结流程：
       （1）请求A进行写操作，删除缓存后，工作正在进行中......A还么有彻底更新完
       （2）请求B开工，查询redis发现缓存不存在
       （3）请求B继续，去数据库查询得到了myslq中的旧值
       （4）请求B将旧值写入redis缓存
       （5）请求A将新值写入mysql数据库
       上述情况就会导致不一致的情形出现。

       先删除缓存，再更新数据库 : 如果数据库更新失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时，从数据库中读取到旧值

       解决方案?
         采用延时双删策略 :代码详见: CacheConsistence.doubleDeleteUser()

       延时双删存在以下问题?
         1.这个删除该休眠多久呢?
           线程Asleep的时间，就需要大于线程B读取数据再写入缓存的时间。

          这个时间怎么确定呢？

           在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，自行评估自己的项目的读数据业务逻辑的耗时，
           以此为基础来进行估算。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上加百毫秒即可。

           这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

         2. 当前演示的效果是mysql单机，如果mysql主从读写分离架构如何？
            （1）请求A进行写操作，删除缓存
            （2）请求A将数据写入数据库了，
            （3）请求B查询缓存发现，缓存没有值
            （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
            （5）请求B将旧值写入缓存
            （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。

            只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms

         3. 这种同步淘汰策略，吞吐量降低怎么办？
            异步线程删除，代码详见： CacheConsistence.asyncDoubleDeleteUser()

    3. 先更新数据库，再删除缓存  生产推荐
       异常问题？
         先更新数据库，再删除缓存，假如缓存删除失败或者来不及，导致请求再次访问redis时缓存命中，读取到的是缓存旧值。只会出现短暂的不一致，缓存过期之后，就会一致
       解决方案？
         1 可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用Kafka/RabbitMQ等）。
         2 当程序没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。
         3 如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试
         4 如果重试超过的一定次数后还是没有成功，我们就需要向业务层发送报错信息了，通知运维人员。



    总结缓存一致性
      方案2和方案3用那个？利弊如何
       在大多数业务场景下，我们会把Redis作为只读缓存使用。假如定位是只读缓存来说，
       理论上既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存，但是没有完美方案，两害相衡趋其轻的原则

       个人建议是，优先使用先更新数据库，再删除缓存的方案。理由如下：

       1 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，严重导致打满mysql。

       2 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。

       如果使用先更新数据库，再删除缓存的方案？
         如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。

       详见： 缓存双写一致性.png






