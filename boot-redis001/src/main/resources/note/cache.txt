
1.缓存雪崩
  1.是什么？
    1. redis主机挂了，Redis 全盘崩溃
    2. 比如缓存中有大量数据同时过期
  2.解决：
    2.1 redis缓存集群实现高可用
       主从+哨兵/ Redis Cluster
    2.2 ehcache本地缓存 + Hystrix或者阿里sentinel限流&降级

    2.3 开启Redis持久化机制aof/rdb，尽快恢复缓存集群

    详见：cache-snowslide.png

2.缓存穿透
  1.是什么？
    一般情况下，先查询缓存redis是否有该条数据，缓存中没有时，再查询数据库。
    当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。
    缓存透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。

  2.危害
     会把数据库打爆

  3. 解决？
    3.1 空对象缓存或者缺省值
       一般情况下是可以解决问题，但是治标不治本
       例如：黑客或者恶意攻击
          id相同请求系统 : 第一次打到mysql，空对象缓存后第二次就返回null了，避免mysql被攻击，不用再到数据库中去走一圈了
          id不同请求系统 : 由于存在空对象缓存和缓存回写(看自己业务不限死)，redis中的无关紧要的key也会越写越多(记得设置redis过期时间)

    3.2 Google布隆过滤器Guava解决缓存穿透
        Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中不需要手动实现一个布隆过滤器

        Guava’s BloomFilter 源码剖析:
          详见：https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/BloomFilter.java
          使用详见：GuavaBloomfilter

        Guava 提供的布隆过滤器的实现还是很不错的 （想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用 ，而现在互联网一般都是分布式的场景。

    3.3 Redis布隆过滤器解决缓存穿透
        案例:白名单过滤器
          详见：白名单架构.png 实现：RedissonBloomFilter

3.布隆过滤器：
   1.是什么？
      布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。
      它实际上是一个很长的二进制数组+一系列随机hash算法映射函数，主要用于判断一个元素是否在集合中。
   2.特点：
      1.高效地插入和查询，占用空间少，返回的结果是不确定性的。
      2.一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在。
      3.布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。
      4.误判只会发生在过滤器没有添加过的元素，对于添加过的元素不会发生误判。
      综上： 可以保证的是，如果布隆过滤器判断一个元素不在一个集合中，那这个元素一定不会在集合中。

   3.布隆过滤器的使用场景：
      1.解决缓存穿透的问题
        把已存在数据的key存在布隆过滤器中，相当于redis前面挡着一个布隆过滤器。
          当有新的请求时，先到布隆过滤器中查询是否存在：
          如果布隆过滤器中不存在该条数据则直接返回；
          如果布隆过滤器中已存在，才去查询缓存redis，如果redis里没查询到则穿透到Mysql数据库
      2.黑名单校验
        发现存在黑名单中的，就执行特定操作。比如：识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。

        假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。
        把所有黑名单都放在布隆过滤器中，在收到邮件时，判断邮件地址是否在布隆过滤器中即可。

   4.布隆过滤器原理
      布隆过滤器(Bloom Filter) 是一种专门用来解决去重问题的高级数据结构。
      实质就是一个大型位数组和几个不同的无偏hash函数(无偏表示分布均匀)。由一个初值都为零的bit数组和多个个哈希函数构成，用来快速判断某个数据是否存在。但是跟 HyperLogLog 一样，它也一样有那么一点点不精确，也存在一定的误判概率

      添加key时
        使用多个hash函数对key进行hash运算得到一个整数索引值，对位数组长度进行取模运算得到一个位置，
        每个hash函数都会得到一个不同的位置，将这几个位置都置1就完成了add操作。

      查询key时
        只要有其中一位是零就表示这个key不存在，但如果都是1，则不一定存在对应的key。
      结论：
        有，是可能有
        无，是肯定无

   5.总结：
      1.使用时最好不要让实际元素数量远大于初始化数量。
      2.当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，重新分配一个 size 更大的过滤器，再将所有的历史元素批量 add 进行。

   6.布隆过滤器优缺点
     优点:
       高效地插入和查询，占用空间少
     缺点：
       1.不能删除元素。因为删掉元素会导致误判率增加，因为hash冲突同一个位置可能存的东西是多个共有的，删除一个元素的同时可能也把其它的删除了。
       2.存在误判，不同的数据可能出来相同的hash值


4.缓存击穿
   1.是什么？
       大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。
   2.危害？
       会造成某一时刻数据库请求量过大，压力剧增。
   3.解决？
     方案1：
       对于访问频繁的热点key，干脆就不设置过期时间。
     方案2：
       互斥更新，差异化失效时间，详见：DoubleProductController具体代码实现，双缓存方案.png
     方案3：
       互斥独占锁防止击穿， 详见：UserService#queryUserById02


5.缓存问题解决：详见：缓存问题解决.png





